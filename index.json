[
{
	"uri": "/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Contents:\nWhat is CI / CD? Benefits of CI / CD in DevOps Popular Tools for CI / CD Challenges in Implementing CI / CD What is CI / CD? Continuous Integration (CI)\nCI (Continuous Integration) is a software development practice where developers frequently integrate new code into a shared repository. Whenever there is a change in the source code, the system automatically builds and runs tests to verify the correctness of the code. Objective: To ensure that code changes can be easily integrated without causing issues in the shared system. CI helps detect errors early in the development process, minimizing issues when integrating code from different sources. Continuous Delivery (CD) and Continuous Deployment (CD)\nContinuous Delivery: After successful code integration (CI), CD ensures that the source code is always ready to be deployed to production or any other environment. The deployment process can be automated or require human approval. Continuous Deployment: This is a higher level of Continuous Delivery, where every code change that passes tests is automatically deployed directly to the production environment without human intervention. Why is CI/CD important in modern software development?\nFast and Continuous: In today’s software development context, quick and continuous software releases are crucial. CI/CD ensures that new features and bug fixes can be quickly deployed to users. Risk Reduction: CI/CD helps reduce risks by detecting errors early in the development process and ensuring that the source code is always ready for deployment. Process Automation: CI/CD automates the process from integration to deployment, reducing the workload for development and operations teams. Benefits of CI / CD in DevOps Automation and Reduction of Human Error\nCI/CD automates steps such as building, testing, and deployment, minimizing human intervention in this process. It enhances efficiency and reduces errors caused by human mistakes. Quickly Bring New Features to Market\nCI/CD allows development teams to quickly deliver new features, improvements, and bug fixes to users. Businesses can respond quickly to market demands and maintain a competitive advantage. Enhanced Collaboration Between Development and Operations Teams\nCI/CD is a key part of DevOps, where development and operations teams work closely together. Continuous integration and deployment help break down barriers between teams, enhancing understanding and coordination in the software development process. Popular Tools for CI / CD GitHub Actions\nGitHub Actions is a built-in CI/CD service on GitHub that allows you to automate software development workflows directly in your repository. Benefits: Direct integration with GitHub, easy workflow setup, supports multiple types of actions and environments, from Linux and macOS to Windows. AWS CodePipeline, AWS CodeBuild, AWS CodeDeploy\nAWS provides powerful CI/CD services that enable continuous integration and deployment in a cloud environment. Benefits: Deep integration with other AWS services, making it easy to build and deploy applications on the AWS platform. Jenkins\nJenkins is one of the most popular CI/CD tools available today, providing automation capabilities from build to test to deployment. Benefits: Jenkins is open-source, easily integrates with many other tools like Git, Docker, and Kubernetes. It also has a large community with many supporting plugins. GitLab CI/CD\nGitLab offers a built-in CI/CD solution that allows users to easily set up pipelines directly in their repository. Benefits: GitLab CI/CD can manage the entire process from source code to deployment with a simple interface and tight integration with GitLab. CircleCI\nCircleCI is a CI/CD platform as a service that strongly supports projects using containers and microservices. Benefits: CircleCI has fast build and deploy speeds and supports custom environments using Docker. Challenges in Implementing CI / CD Complexity in Setup\nSetting up and configuring a complex CI/CD pipeline may require extensive knowledge of tools and processes. Managing configuration files, environments, and integration with other tools can be challenging, especially for large projects. Security\nAutomating deployments can create security vulnerabilities if not configured correctly. Managing sensitive information such as API keys and login credentials in the pipeline needs to be done carefully. Resource and Cost Management\nWhen using cloud services for CI/CD, inefficient resource management can lead to high costs. Strategies are needed to optimize resources and minimize costs during automated deployment. "
},
{
	"uri": "/",
	"title": "CI/CD on AWS",
	"tags": [],
	"description": "",
	"content": "Setting up CI/CD with GitHub Actions Welcome to the workshop where you will explore and apply CI/CD techniques to optimize your software development process. The workshop is divided into three main parts:\nUnderstanding CI/CD: We will start by exploring the concept of CI/CD, its role, and benefits in software development, helping you gain a clear understanding of the automation process from code integration to application deployment.\nUnderstanding GitHub Actions: This section focuses on GitHub Actions, the CI/CD tool integrated into GitHub. You will learn how to configure workflows, jobs, steps, and actions, as well as other related concepts to automate the development process.\nHands-On CI/CD Setup for a Next.js Project: We will apply the knowledge learned by setting up a basic CI/CD pipeline for a Next.js project. You will be guided step-by-step through cloning the project, installing dependencies, writing and running unit tests, and configuring and deploying the application to GitHub Pages.\nThe goal of this workshop is to help you master the concepts of CI/CD and GitHub Actions and confidently set up and manage the CI/CD process for your own projects.\nLet\u0026rsquo;s get started and automate your deployment process now!\nOutline Introduce CI/CD on Github Actions Setting up CI/CD for project "
},
{
	"uri": "/2-github-actions/",
	"title": "CI/CD on Github Actions",
	"tags": [],
	"description": "",
	"content": "Contents:\nWhat is GitHub Actions? Workflow Job Step Action Event Artifact Integration with other services and tools Benefits of using GitHub Actions What is GitHub Actions? GitHub Actions is a CI/CD service integrated into GitHub that allows you to automate software development workflows from code checks, builds, to deployments.\nGitHub Actions supports the integration and automation of the development process directly within your GitHub repository, making it easy to set up workflows to manage and deploy applications.\nWorkflow Description: A Workflow is the primary configuration in GitHub Actions, representing the entire automation process. A workflow is a YAML file containing the steps and actions to be executed, from build to deployment.\nFunction: Workflow defines the jobs and steps to be performed when an event occurs, such as a pull request or a code push to the repository. It can include multiple jobs and steps, allowing for a flexible and manageable organization of tasks.\nJob Description: A Job is a unit of work within a workflow, usually representing a stage in the CI/CD process. A workflow can contain multiple jobs.\nFunction: Jobs execute specific steps such as build, test, or deploy. Jobs can run in parallel or sequentially, depending on your configuration.\nStep Description: A Step is a specific task within a job, including commands or the use of actions.\nFunction: Each step performs a specific action such as running a shell command, installing dependencies, or calling an action from the marketplace. Steps are executed in order within a job.\nAction Description: An Action is a reusable component in GitHub Actions that provides specific tasks like installing software, running tests, or deploying.\nFunction: Actions can be community-created or custom-made and can be used in workflows to perform common tasks. You can find and use actions from the GitHub Marketplace.\nEvent Description: An Event is a trigger that initiates a workflow in GitHub Actions, such as a code push, pull request, or events from the GitHub API.\nFunction: Events determine when and why a workflow is triggered. You can configure workflows to run automatically based on specific events.\nArtifact Description: An Artifact is a file or result generated during the workflow execution that can be stored and used in subsequent steps.\nFunction: Artifacts are often used to store build results, logs, or files needed for the next steps in a workflow.\nIntegration with other services and tools GitHub Actions integrates closely with other services and tools, enhancing the capabilities of your CI/CD pipeline. You can integrate with cloud services like AWS as well as tools like Docker, Kubernetes, and many more. Benefits of using GitHub Actions Direct Integration: GitHub Actions integrates directly with GitHub, allowing you to manage your development workflow within your repository without needing an external CI/CD tool.\nFlexible Customization: With GitHub Actions, you can easily customize workflows and use actions from the marketplace to suit the specific needs of your project.\nSpeed and Efficiency: Automating the CI/CD process helps reduce errors, improves development and deployment speed, and ensures the source code is always ready for release.\n"
},
{
	"uri": "/3-ci-cd-a-sample-project_/",
	"title": "Setting up CI/CD for project",
	"tags": [],
	"description": "",
	"content": "In this section, we will set up a basic CI/CD pipeline for a Next.js project using GitHub Actions. The goal is to get familiar with automating the process from committing code to deploying the application to a production environment. Through this, you will understand how GitHub Actions can help optimize and automate development and deployment steps in your project.\nThe process will include the following sections:\nPrepare the working environment by cloning a sample Next.js project and configuring the necessary dependencies.\nCustomize and check Unit Tests to ensure the code is thoroughly tested before deployment.\nSet up GitHub Actions to automate the build and testing process whenever there is a code change.\nDeploy the application to GitHub Pages, allowing us to easily test and use the application after updates.\nWith these sections, you will clearly understand how to implement a simple yet effective CI/CD process for your project.\nStep 1: Clone the sample NextJS project to your local machine\nRepository link: https://github.com/vercel/next.js Step 2: Select the folder examples/with-jest and open it in the terminal\nThis is a pre-configured Next.js project with unit tests. Step 3: Install npm dependencies\nRun the command npm install to install all necessary dependencies for the project. Step 4: Run the project\nUse the command npm run dev to start the Next.js development server. Step 5: Access localhost:3000 to view the running application.\nStep 6: Edit the package.json file\nOpen the package.json file and change the line \u0026ldquo;test\u0026rdquo;: \u0026ldquo;jest \u0026ndash;watch\u0026rdquo; to \u0026ldquo;test\u0026rdquo;: \u0026ldquo;jest \u0026ndash;coverage\u0026rdquo; to view the test coverage. Step 7: Run the command npm run test to execute the tests.\nStep 8: The source code coverage report will include information such as:\nFile: List of files that have been tested. % Stmts: The percentage of statements that have been tested. % Branch: The percentage of conditional branches in the code that have been tested. % Funcs: The percentage of functions that have been tested. % Lines: The percentage of code lines that have been tested. Uncovered Line #s: The lines of code that have not been tested. Step 9: Customize some unit tests\nOpen the file app/blog/page.tsx. Add or modify unit tests to cover additional functionalities or scenarios. Step 10: Continue with the file app/blog/page.test.tsx\nMake changes in the test file app/blog/page.test.tsx to match any changes made in app/blog/page.tsx. Step 11: Rerun the test suite\nRun the command npm run test to check the unit tests. Ensure that all unit tests pass and that there is at least one new unit test covered. Step 12: Push the project to GitHub\nMake sure you have committed all changes in Git and pushed them to your GitHub repository. Step 13: Successfully pushed the project to GitHub\nConfirm that the project has been successfully pushed to GitHub by checking your repository. Step 14: On the repository, select Actions\nGo to the Actions tab on your GitHub repository to configure GitHub Actions. Step 15: Find NodeJS and select Configure NodeJS\nFind the pre-configured NodeJS workflow and select Configure NodeJS to edit or set up automated steps. Step 16: NodeJS Actions interface\nIn this interface, you can add, edit, or delete the necessary steps for your CI/CD process. Step 17: Select Commit Changes\nAfter editing, select Commit Changes to save your workflow changes. Step 18: After committing changes, there will be a .github/workflows folder in the repository\nThis folder contains .yml files for working with GitHub Actions, where you can view and edit CI/CD tasks. Step 19: Create and switch to a different branch: branch \u0026ldquo;update\u0026rdquo;\nCreate a new branch named \u0026ldquo;update\u0026rdquo; and switch to that branch.\nAdd a few lines of code or make necessary changes.\nStep 20: Push new code to the \u0026ldquo;update\u0026rdquo; branch\nPush the changes to the \u0026ldquo;update\u0026rdquo; branch on GitHub. Step 21: Select Compare \u0026amp; Pull Request\nOn GitHub, select Compare \u0026amp; Pull Request to start merging code from the \u0026ldquo;update\u0026rdquo; branch into the \u0026ldquo;main\u0026rdquo; branch. Step 22: Create a pull request to the main branch\nFill in the necessary information and create a pull request to merge the code into the main branch. Step 23: The system automatically runs the jobs listed in the nodejs.yml file\nAfter creating the pull request, GitHub Actions will automatically run the jobs configured in the nodejs.yml file. Step 24: Go to Actions to check the details of the completed jobs\nAccess the Actions tab to check the status and results of the CI/CD jobs. Step 25: Go to Settings, select Pages to Deploy\nGo to the Settings section of the repository and select Pages to configure and deploy your application. Step 26: In the Source section, select GitHub Actions\nIn the Source configuration for GitHub Pages, select GitHub Actions to use the configured workflow for deployment. Step 27: Select Configure\nSelect Configure to finalize the deployment configuration through GitHub Actions. Step 28: Select Commit Changes\nAfter completing the configuration, select \u0026ldquo;Commit Changes\u0026rdquo; to save the changes. Step 29: Merge Pull Request\nAfter all the testing and build jobs in GitHub Actions have successfully completed, you need to merge the pull request from the \u0026ldquo;update\u0026rdquo; branch into the \u0026ldquo;main\u0026rdquo; branch. Bước 30: Merge\nStep 31: Create \u0026ldquo;production\u0026rdquo; branch\nIn the \u0026ldquo;Code\u0026rdquo; section, select \u0026ldquo;New Branch\u0026rdquo; to create a new branch named \u0026ldquo;production.\u0026rdquo; Step 32: Pull Request from main to production\nCreate a pull request to merge changes from the \u0026ldquo;main\u0026rdquo; branch to the \u0026ldquo;production\u0026rdquo; branch. Go to your repository on GitHub, select \u0026ldquo;Compare \u0026amp; Pull Request\u0026rdquo; from the \u0026ldquo;main\u0026rdquo; branch to the \u0026ldquo;production\u0026rdquo; branch. Step 33: Add \u0026ldquo;release\u0026rdquo; title and select Create pull request\nStep 34: Successfully set up CI/CD system\nAfter creating and merging the pull request from \u0026ldquo;main\u0026rdquo; to \u0026ldquo;production,\u0026rdquo; the CI/CD system (GitHub Actions) will automatically run tasks to deploy the application from the \u0026ldquo;production\u0026rdquo; branch.\nCheck these activities in the Actions tab to ensure all steps have been completed successfully and the application has been deployed to the production environment.\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]